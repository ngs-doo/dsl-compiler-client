{"Scala/namespace.SystemConfiguration.scala":"package namespace\r\n\r\nimport hr.ngs.patterns._\r\n\r\nobject SystemConfiguration {\r\n\tdef initialize(container: IContainer) {\t\r\n\t\tpostgresUtils.loadIndexes(container[org.pgscala.PGSessionFactory])\r\n\t\tmyModule.postgres.initialize(container)\r\n\t}\r\n}","Scala/namespace.myModule.postgres.scala":"package namespace\r\npackage myModule\r\n\r\nimport hr.ngs.patterns._\r\n\r\npackage object postgres {\r\n\tdef initialize(container: IContainer) {\r\n\t\tval locator = container[IServiceLocator]\r\n\t\t\r\n\t\tnamespace.myModule.postgres.AConverter.initializeProperties \r\n\t\tcontainer.register[namespace.myModule.postgres.ARepository, namespace.myModule.IARepository]\r\n\t\tcontainer.register[namespace.myModule.postgres.ARepository, IRepository[namespace.myModule.A]]\r\n\t\tnamespace.myModule.postgres.BConverter.initializeProperties \r\n\t\tcontainer.register[namespace.myModule.postgres.BRepository, namespace.myModule.IBRepository]\r\n\t\tcontainer.register[namespace.myModule.postgres.BRepository, IRepository[namespace.myModule.B]]\r\n\t\tnamespace.myModule.postgres.snowBAConverter.initializeProperties \r\n\t\tcontainer.register[namespace.myModule.postgres.snowBARepository, IRepository[namespace.myModule.snowBA]]\r\n\t\tcontainer.register[namespace.myModule.postgres.ARepository, IPersistableRepository[namespace.myModule.A]]\r\n\t\tcontainer.register[namespace.myModule.postgres.BRepository, IPersistableRepository[namespace.myModule.B]]\r\n\t}\r\n}","Scala/namespace.myModule.postgres.AConverter.scala":"package namespace.myModule.postgres\r\n\r\n\r\n\r\nimport org.pgscala.converters._\r\nimport org.pgscala.util._\r\nimport hr.ngs.patterns._\r\n\r\nobject AConverter {\r\n\r\n\tprivate val logger = org.slf4j.LoggerFactory.getLogger(getClass)\r\n\r\n\tdef fromPGString(record: String, locator: IServiceLocator): namespace.myModule.A = {\r\n\t\tval items = PGRecord.unpack(record)\r\n\t\tnamespace.myModule.A.buildInternal(\r\n\t\t\t__locator = locator\r\n\t\t, URI = items(URIPos)\r\n\t\t, ID = PGIntConverter.fromPGString(items(IDPos))\r\n\t\t, i = PGIntConverter.fromPGString(items(iPos))\r\n\t\t, s = PGStringConverter.fromPGString(items(sPos))\r\n\t\t, f = PGFloatConverter.fromPGString(items(fPos))\r\n\t\t)\r\n\t}\r\n\r\n\tdef fromPGStringExtended(record: String, locator: IServiceLocator): namespace.myModule.A = {\r\n\t\tval items = PGRecord.unpack(record)\r\n\t\tnamespace.myModule.A.buildInternal(\r\n\t\t\t__locator = locator\r\n\t\t, URI = items(URIPosExtended)\r\n\t\t, ID = PGIntConverter.fromPGString(items(IDPosExtended))\r\n\t\t, i = PGIntConverter.fromPGString(items(iPosExtended))\r\n\t\t, s = PGStringConverter.fromPGString(items(sPosExtended))\r\n\t\t, f = PGFloatConverter.fromPGString(items(fPosExtended))\r\n\t\t)\r\n\t}\r\n\r\n\tdef toPGString(item: namespace.myModule.A): String = {\r\n\t\tval items = new Array[String](columnCount) \r\n\t\titems(URIPos) = item.URI\r\n\t\titems(IDPos) = PGIntConverter.toPGString(item.ID)\r\n\t\titems(iPos) = PGIntConverter.toPGString(item.i)\r\n\t\titems(sPos) = PGStringConverter.toPGString(item.s)\r\n\t\titems(fPos) = PGFloatConverter.toPGString(item.f)\r\n\t\tPGRecord.pack(items)\r\n\t}\r\n\r\n\tdef toPGStringExtended(item: namespace.myModule.A): String = {\r\n\t\tval items = new Array[String](extendedColumnCount) \r\n\t\titems(URIPosExtended) = item.URI\r\n\t\titems(IDPosExtended) = PGIntConverter.toPGString(item.ID)\r\n\t\titems(iPosExtended) = PGIntConverter.toPGString(item.i)\r\n\t\titems(sPosExtended) = PGStringConverter.toPGString(item.s)\r\n\t\titems(fPosExtended) = PGFloatConverter.toPGString(item.f)\r\n\t\tPGRecord.pack(items)\r\n\t}\r\n\r\n\tprivate var columnCount = -1\r\n\tprivate var extendedColumnCount = -1\r\n\r\n\tdef initializeProperties() {\r\n\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"A_entity\").get(\"URI\") match {\r\n\t\t\tcase Some(index) => URIPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"URI\" in type myModule.A_entity. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_A_type-\").get(\"URI\") match {\r\n\t\t\tcase Some(index) => URIPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"URI\" in type myModule.A. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tcolumnCount = postgresUtils.getColumnCount(\"myModule\", \"A_entity\")\r\n\t\textendedColumnCount = postgresUtils.getColumnCount(\"myModule\", \"-ngs_A_type-\")\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"A_entity\").get(\"ID\") match {\r\n\t\t\tcase Some(index) => IDPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"ID\" in type myModule.A_entity. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_A_type-\").get(\"ID\") match {\r\n\t\t\tcase Some(index) => IDPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"ID\" in type myModule.A. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"A_entity\").get(\"i\") match {\r\n\t\t\tcase Some(index) => iPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"i\" in type myModule.A_entity. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_A_type-\").get(\"i\") match {\r\n\t\t\tcase Some(index) => iPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"i\" in type myModule.A. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"A_entity\").get(\"s\") match {\r\n\t\t\tcase Some(index) => sPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"s\" in type myModule.A_entity. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_A_type-\").get(\"s\") match {\r\n\t\t\tcase Some(index) => sPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"s\" in type myModule.A. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"A_entity\").get(\"f\") match {\r\n\t\t\tcase Some(index) => fPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"f\" in type myModule.A_entity. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_A_type-\").get(\"f\") match {\r\n\t\t\tcase Some(index) => fPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"f\" in type myModule.A. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t}\r\n\r\n\t\r\n\tprivate var URIPos = -1 \r\n\tprivate var URIPosExtended = -1 \r\n\tprivate var IDPos = -1 \r\n\tprivate var IDPosExtended = -1 \r\n\t\r\n\tdef buildURI(ID: Int) : String = {\r\n\t\tval _uriParts = new Array[String](1) \r\n\t\t_uriParts(0) = PGIntConverter.toPGString(ID)\r\n\t\tpostgres.Utils.buildURI(_uriParts)\r\n\t}\r\n\tprivate var iPos = -1 \r\n\tprivate var iPosExtended = -1 \r\n\tprivate var sPos = -1 \r\n\tprivate var sPosExtended = -1 \r\n\tprivate var fPos = -1 \r\n\tprivate var fPosExtended = -1 \r\n}\r\n","Scala/namespace.myModule.A.scala":"package namespace.myModule\r\n\r\nimport hr.ngs.patterns._\r\n\r\n\r\n\r\n\r\nclass A @com.fasterxml.jackson.annotation.JsonIgnore  private(\r\n\t  private var _URI: String,\r\n\t  private var _ID: Int,\r\n\t  private var _i: Int,\r\n\t  private var _s: String,\r\n\t  private var _f: Float,\r\n\t  @transient private val __locator: Option[IServiceLocator]\r\n\t) extends Serializable with IIdentifiable {\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonProperty(\"URI\")\r\n\tdef URI = { \r\n\t\t_URI\r\n\t}\r\n\r\n\t\r\n\tprivate [namespace] def URI_= (value: String) { \r\n\t\t_URI = value\r\n\t\t\r\n\t}\r\n\r\n\t\r\n\toverride def hashCode = URI.hashCode\r\n\toverride def equals(o: Any) = o match {\r\n\t\tcase c: A => c.URI == URI\r\n\t\tcase _ => false\r\n\t}\r\n\r\n\toverride def toString = \"A(\"+ URI +\")\"\r\n\t\r\n\t\t\r\n\t def copy(i: Int = this._i, s: String = this._s, f: Float = this._f): A = {\r\n\t\t\r\n\r\n\t\t\t\r\n\trequire(s ne null, \"Null value was provided for property \\\"s\\\"\")\r\n\t\tnew A(_URI = this.URI, __locator = this.__locator, _ID = _ID, _i = i, _s = s, _f = f)\r\n\t}\r\n\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonCreator private def this(\r\n\t\t@com.fasterxml.jackson.annotation.JacksonInject(\"__locator\") __locator: IServiceLocator\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"URI\") URI: String\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"ID\") ID: Int\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"i\") i: Int\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"s\") s: String\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"f\") f: Float\r\n\t) =\r\n\t  this(__locator = Some(__locator), _URI = URI, _ID = ID, _i = i, _s = if (s == null) \"\" else s, _f = f)\r\n\r\n\t\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonProperty(\"ID\")\r\n\tdef ID = { \r\n\t\t_ID\r\n\t}\r\n\r\n\t\r\n\tprivate [namespace] def ID_= (value: Int) { \r\n\t\t_ID = value\r\n\t\t\r\n\t}\r\n\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonIgnore\r\n\tdef isNewAggregate() = __locator == None || _URI == null\r\n\t\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonProperty(\"i\")\r\n\tdef i = { \r\n\t\t_i\r\n\t}\r\n\r\n\t\r\n\tdef i_= (value: Int) { \r\n\t\t_i = value\r\n\t\t\r\n\t}\r\n\r\n\t\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonProperty(\"s\")\r\n\tdef s = { \r\n\t\t_s\r\n\t}\r\n\r\n\t\r\n\tdef s_= (value: String) { \r\n\t\t_s = value\r\n\t\t\r\n\t}\r\n\r\n\t\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonProperty(\"f\")\r\n\tdef f = { \r\n\t\t_f\r\n\t}\r\n\r\n\t\r\n\tdef f_= (value: Float) { \r\n\t\t_f = value\r\n\t\t\r\n\t}\r\n\r\n}\r\n\r\nobject A{\r\n\r\n\tdef apply(\r\n\t\ti: Int = 0\r\n\t, s: String = \"\"\r\n\t, f: Float = 0.0f\r\n\t) = {\r\n\t\trequire(s ne null, \"Null value was provided for property \\\"s\\\"\")\r\n\t\tnew A(\r\n\t\t\t__locator = None\r\n\t\t, _URI = java.util.UUID.randomUUID.toString\r\n\t\t, _ID = 0\r\n\t\t, _i = i\r\n\t\t, _s = s\r\n\t\t, _f = f)\r\n\t}\r\n\r\n\t\r\n\t\t\t\r\n\tprivate[myModule] def buildInternal(__locator: IServiceLocator\r\n\t\t, URI: String\r\n\t\t, ID: Int\r\n\t\t, i: Int\r\n\t\t, s: String\r\n\t\t, f: Float) = \r\n\t\tnew A(\r\n\t\t\t__locator = Some(__locator)\r\n\t\t, _URI = URI\r\n\t\t, _ID = ID\r\n\t\t, _i = i\r\n\t\t, _s = s\r\n\t\t, _f = f)\r\n\r\n}\r\n","Scala/namespace.myModule.postgres.ARepository.scala":"package namespace.myModule.postgres\r\n\r\nimport hr.ngs.patterns._\r\n\r\n\r\n\r\n\r\nclass ARepository(\r\n\t  private val sessionFactory: org.pgscala.PGSessionFactory,\r\n\t  private val locator: IServiceLocator\r\n\t) extends namespace.myModule.IARepository {\r\n\t\r\n\t\r\n\t\r\n\timport org.pgscala._\r\n\r\n\tval createFromResultSet = (rS: PGScalaResultSet) =>\r\n\t\tnamespace.myModule.postgres.AConverter.fromPGString(rS.one[String], locator)\r\n\r\n\tdef find(uris: Traversable[String]): IndexedSeq[namespace.myModule.A] = {\r\n\t\tval pks = if(uris eq null) Array.empty[String] else uris.filter(_ ne null).toArray\r\n\t\tif (pks.isEmpty) {\r\n\t\t\tIndexedSeq.empty\r\n\t\t}\r\n\t\telse {\r\n\t\t\tval formattedUris = postgres.Utils.buildSimpleUriList(pks)\r\n\t\t\tsessionFactory.using( _.arr(\"\"\"SELECT r\r\nFROM \"myModule\".\"A_entity\" r\r\nWHERE r.\"ID\" IN (%s)\"\"\".format(formattedUris)) (createFromResultSet)\r\n\t\t\t)\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate val typeConverter = namespace.myModule.postgres.AConverter\r\n\tprivate val rootTypeConverter = typeConverter.toPGString _\r\n\r\n\tdef persist(\r\n\t\t  insert: Traversable[namespace.myModule.A]\r\n\t\t, update: Traversable[(namespace.myModule.A, namespace.myModule.A)]\r\n\t\t, delete: Traversable[namespace.myModule.A]): IndexedSeq[String] = {\r\n\r\n\t\tsessionFactory.using{ dbSession =>\r\n\t\t\tval insertValues = insert.toArray\r\n\t\t\tval updateValues = update.toArray\r\n\t\t\tval deleteValues = delete.toArray\r\n\r\n\r\n\t\t\tif(insertValues.nonEmpty) {\r\n\t\t\t\tval ids = dbSession.getArr[Int](\"\"\"/*NO LOAD BALANCE*/SELECT nextval('\"myModule\".\"A_ID_seq\"'::regclass)::int FROM generate_series(1, @1);\"\"\", insertValues.size)\r\n\r\n\t\t\t\tinsertValues.zip(ids) foreach { case (item, id) => \r\n\t\t\t\t\titem.ID = id\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\tinsertValues foreach { item => item.URI = namespace.myModule.postgres.AConverter.buildURI(item.ID) }\r\n\t\t\tupdateValues foreach { case(_, item) => item.URI = namespace.myModule.postgres.AConverter.buildURI(item.ID) }\r\n\r\n\t\t\tval sqlCom = new StringBuilder(\"\"\"/*NO LOAD BALANCE*/SELECT \"myModule\".\"persist_A\"(\r\n\t\t\t\t\t%s::\"myModule\".\"A_entity\"[],\r\n\t\t\t\t\t%s::\"myModule\".\"A_entity\"[],\r\n\t\t\t\t\t%s::\"myModule\".\"A_entity\"[],\r\n\t\t\t\t\t%s::\"myModule\".\"A_entity\"[]\"\"\".format(\r\n\t\t\t\tpostgres.Utils.createArrayLiteral(insertValues, rootTypeConverter),\r\n\t\t\t\tpostgres.Utils.createArrayLiteral(updateValues map(_._1), rootTypeConverter),\r\n\t\t\t\tpostgres.Utils.createArrayLiteral(updateValues map(_._2), rootTypeConverter),\r\n\t\t\t\tpostgres.Utils.createArrayLiteral(deleteValues, rootTypeConverter)))\r\n\r\n\t\t\tsqlCom.append(\")\")\r\n\r\n\t\t\tdbSession.exec(sqlCom.toString)\r\n\r\n\r\n\t\t\tinsertValues.map(_.URI)\r\n\t\t} // using\r\n\t}\r\n\r\n}\r\n","Scala/namespace.myModule.IARepository.scala":"package namespace.myModule\r\n\r\nimport hr.ngs.patterns._\r\n\r\n\r\n\r\ntrait IARepository \textends IRepository[namespace.myModule.A]\twith IPersistableRepository[namespace.myModule.A] {\r\n\t\r\n}\r\n","Scala/namespace.myModule.postgres.BConverter.scala":"package namespace.myModule.postgres\r\n\r\n\r\n\r\nimport org.pgscala.converters._\r\nimport org.pgscala.util._\r\nimport hr.ngs.patterns._\r\n\r\nobject BConverter {\r\n\r\n\tprivate val logger = org.slf4j.LoggerFactory.getLogger(getClass)\r\n\r\n\tdef fromPGString(record: String, locator: IServiceLocator): namespace.myModule.B = {\r\n\t\tval items = PGRecord.unpack(record)\r\n\t\tnamespace.myModule.B.buildInternal(\r\n\t\t\t__locator = locator\r\n\t\t, URI = items(URIPos)\r\n\t\t, ID = PGIntConverter.fromPGString(items(IDPos))\r\n\t\t, a = null\r\n\t\t, aURI = items(aURIPos)\r\n\t\t, aID = PGIntConverter.fromPGString(items(aIDPos))\r\n\t\t, i = PGIntConverter.fromPGString(items(iPos))\r\n\t\t, s = PGStringConverter.fromPGString(items(sPos))\r\n\t\t, f = PGFloatConverter.fromPGString(items(fPos))\r\n\t\t)\r\n\t}\r\n\r\n\tdef fromPGStringExtended(record: String, locator: IServiceLocator): namespace.myModule.B = {\r\n\t\tval items = PGRecord.unpack(record)\r\n\t\tnamespace.myModule.B.buildInternal(\r\n\t\t\t__locator = locator\r\n\t\t, URI = items(URIPosExtended)\r\n\t\t, ID = PGIntConverter.fromPGString(items(IDPosExtended))\r\n\t\t, a = null\r\n\t\t, aURI = items(aURIPosExtended)\r\n\t\t, aID = PGIntConverter.fromPGString(items(aIDPosExtended))\r\n\t\t, i = PGIntConverter.fromPGString(items(iPosExtended))\r\n\t\t, s = PGStringConverter.fromPGString(items(sPosExtended))\r\n\t\t, f = PGFloatConverter.fromPGString(items(fPosExtended))\r\n\t\t)\r\n\t}\r\n\r\n\tdef toPGString(item: namespace.myModule.B): String = {\r\n\t\tval items = new Array[String](columnCount) \r\n\t\titems(URIPos) = item.URI\r\n\t\titems(IDPos) = PGIntConverter.toPGString(item.ID)\r\n\t\titems(aURIPos) = item.aURI\r\n\t\titems(aIDPos) = PGIntConverter.toPGString(item.aID)\r\n\t\titems(iPos) = PGIntConverter.toPGString(item.i)\r\n\t\titems(sPos) = PGStringConverter.toPGString(item.s)\r\n\t\titems(fPos) = PGFloatConverter.toPGString(item.f)\r\n\t\tPGRecord.pack(items)\r\n\t}\r\n\r\n\tdef toPGStringExtended(item: namespace.myModule.B): String = {\r\n\t\tval items = new Array[String](extendedColumnCount) \r\n\t\titems(URIPosExtended) = item.URI\r\n\t\titems(IDPosExtended) = PGIntConverter.toPGString(item.ID)\r\n\t\titems(aURIPosExtended) = item.aURI\r\n\t\titems(aIDPosExtended) = PGIntConverter.toPGString(item.aID)\r\n\t\titems(iPosExtended) = PGIntConverter.toPGString(item.i)\r\n\t\titems(sPosExtended) = PGStringConverter.toPGString(item.s)\r\n\t\titems(fPosExtended) = PGFloatConverter.toPGString(item.f)\r\n\t\tPGRecord.pack(items)\r\n\t}\r\n\r\n\tprivate var columnCount = -1\r\n\tprivate var extendedColumnCount = -1\r\n\r\n\tdef initializeProperties() {\r\n\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"B_entity\").get(\"URI\") match {\r\n\t\t\tcase Some(index) => URIPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"URI\" in type myModule.B_entity. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_B_type-\").get(\"URI\") match {\r\n\t\t\tcase Some(index) => URIPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"URI\" in type myModule.B. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tcolumnCount = postgresUtils.getColumnCount(\"myModule\", \"B_entity\")\r\n\t\textendedColumnCount = postgresUtils.getColumnCount(\"myModule\", \"-ngs_B_type-\")\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"B_entity\").get(\"ID\") match {\r\n\t\t\tcase Some(index) => IDPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"ID\" in type myModule.B_entity. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_B_type-\").get(\"ID\") match {\r\n\t\t\tcase Some(index) => IDPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"ID\" in type myModule.B. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"B_entity\").get(\"aURI\") match {\r\n\t\t\tcase Some(index) => aURIPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"aURI\" in type myModule.B_entity. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_B_type-\").get(\"aURI\") match {\r\n\t\t\tcase Some(index) => aURIPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"aURI\" in type myModule.B. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"B_entity\").get(\"aID\") match {\r\n\t\t\tcase Some(index) => aIDPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"aID\" in type myModule.B_entity. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_B_type-\").get(\"aID\") match {\r\n\t\t\tcase Some(index) => aIDPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"aID\" in type myModule.B. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"B_entity\").get(\"i\") match {\r\n\t\t\tcase Some(index) => iPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"i\" in type myModule.B_entity. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_B_type-\").get(\"i\") match {\r\n\t\t\tcase Some(index) => iPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"i\" in type myModule.B. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"B_entity\").get(\"s\") match {\r\n\t\t\tcase Some(index) => sPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"s\" in type myModule.B_entity. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_B_type-\").get(\"s\") match {\r\n\t\t\tcase Some(index) => sPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"s\" in type myModule.B. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"B_entity\").get(\"f\") match {\r\n\t\t\tcase Some(index) => fPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"f\" in type myModule.B_entity. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_B_type-\").get(\"f\") match {\r\n\t\t\tcase Some(index) => fPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"f\" in type myModule.B. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t}\r\n\r\n\t\r\n\tprivate var URIPos = -1 \r\n\tprivate var URIPosExtended = -1 \r\n\tprivate var IDPos = -1 \r\n\tprivate var IDPosExtended = -1 \r\n\t\r\n\tdef buildURI(ID: Int) : String = {\r\n\t\tval _uriParts = new Array[String](1) \r\n\t\t_uriParts(0) = PGIntConverter.toPGString(ID)\r\n\t\tpostgres.Utils.buildURI(_uriParts)\r\n\t}\r\n\tprivate var aURIPos = -1 \r\n\tprivate var aURIPosExtended = -1 \r\n\tprivate var aIDPos = -1 \r\n\tprivate var aIDPosExtended = -1 \r\n\tprivate var iPos = -1 \r\n\tprivate var iPosExtended = -1 \r\n\tprivate var sPos = -1 \r\n\tprivate var sPosExtended = -1 \r\n\tprivate var fPos = -1 \r\n\tprivate var fPosExtended = -1 \r\n}\r\n","Scala/namespace.myModule.B.scala":"package namespace.myModule\r\n\r\nimport hr.ngs.patterns._\r\n\r\n\r\n\r\n\r\nclass B @com.fasterxml.jackson.annotation.JsonIgnore  private(\r\n\t  private var _URI: String,\r\n\t  private var _ID: Int,\r\n\t  @transient private var _a: namespace.myModule.A,\r\n\t  private var _aURI: String,\r\n\t  private var _aID: Int,\r\n\t  private var _i: Int,\r\n\t  private var _s: String,\r\n\t  private var _f: Float,\r\n\t  @transient private val __locator: Option[IServiceLocator]\r\n\t) extends Serializable with IIdentifiable {\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonProperty(\"URI\")\r\n\tdef URI = { \r\n\t\t_URI\r\n\t}\r\n\r\n\t\r\n\tprivate [namespace] def URI_= (value: String) { \r\n\t\t_URI = value\r\n\t\t\r\n\t}\r\n\r\n\t\r\n\toverride def hashCode = URI.hashCode\r\n\toverride def equals(o: Any) = o match {\r\n\t\tcase c: B => c.URI == URI\r\n\t\tcase _ => false\r\n\t}\r\n\r\n\toverride def toString = \"B(\"+ URI +\")\"\r\n\t\r\n\t\t\r\n\t def copy(a: namespace.myModule.A = null, i: Int = this._i, s: String = this._s, f: Float = this._f): B = {\r\n\t\t\r\n\r\n\t\t\t\r\n\trequire(s ne null, \"Null value was provided for property \\\"s\\\"\")\r\n\t\tnew B(_URI = this.URI, __locator = this.__locator, _ID = _ID, _a = if(a != null) a else _a, _aURI = if (a != null) a.URI else this._aURI, _aID = if(a != null) a.ID else this._aID, _i = i, _s = s, _f = f)\r\n\t}\r\n\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonCreator private def this(\r\n\t\t@com.fasterxml.jackson.annotation.JacksonInject(\"__locator\") __locator: IServiceLocator\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"URI\") URI: String\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"ID\") ID: Int\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"aURI\") aURI: String\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"aID\") aID: Int\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"i\") i: Int\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"s\") s: String\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"f\") f: Float\r\n\t) =\r\n\t  this(__locator = Some(__locator), _URI = URI, _ID = ID, _aURI = if (aURI == null) \"\" else aURI, _a = null, _aID = aID, _i = i, _s = if (s == null) \"\" else s, _f = f)\r\n\r\n\t\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonProperty(\"ID\")\r\n\tdef ID = { \r\n\t\t_ID\r\n\t}\r\n\r\n\t\r\n\tprivate [namespace] def ID_= (value: Int) { \r\n\t\t_ID = value\r\n\t\t\r\n\t}\r\n\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonIgnore\r\n\tdef isNewAggregate() = __locator == None || _URI == null\r\n\t\r\n\t\r\n\tdef a = { \r\n\tif(__locator.isDefined) {\r\n\t\t\tif (_a == null || _a.URI != aURI)\r\n\t\t\t\t_a = __locator.get[namespace.myModule.IARepository].find(aURI).orNull\r\n\t\t}\t\t\t\r\n\t\t_a\r\n\t}\r\n\r\n\t\r\n\tdef a_= (value: namespace.myModule.A) { \r\n\t\t_a = value\r\n\t\t\r\n\t\t_aURI = value.URI\r\n\t\t\r\n\t\tif(aID != value.ID)\r\n\t\t\taID = value.ID\r\n\t}\r\n\r\n\t\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonProperty(\"aURI\")\r\n\tdef aURI = {\r\n\t\t\r\n\t\t_aURI\r\n\t}\r\n\r\n\t\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonProperty(\"aID\")\r\n\t def aID = { \r\n\t\t_aID\r\n\t}\r\n\r\n\t\r\n\tprivate [namespace] def aID_= (value: Int) { \r\n\t\t_aID = value\r\n\t\t\r\n\t}\r\n\r\n\t\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonProperty(\"i\")\r\n\tdef i = { \r\n\t\t_i\r\n\t}\r\n\r\n\t\r\n\tdef i_= (value: Int) { \r\n\t\t_i = value\r\n\t\t\r\n\t}\r\n\r\n\t\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonProperty(\"s\")\r\n\tdef s = { \r\n\t\t_s\r\n\t}\r\n\r\n\t\r\n\tdef s_= (value: String) { \r\n\t\t_s = value\r\n\t\t\r\n\t}\r\n\r\n\t\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonProperty(\"f\")\r\n\tdef f = { \r\n\t\t_f\r\n\t}\r\n\r\n\t\r\n\tdef f_= (value: Float) { \r\n\t\t_f = value\r\n\t\t\r\n\t}\r\n\r\n}\r\n\r\nobject B{\r\n\r\n\tdef apply(\r\n\t\ta: namespace.myModule.A\r\n\t, i: Int = 0\r\n\t, s: String = \"\"\r\n\t, f: Float = 0.0f\r\n\t) = {\r\n\t\trequire(a ne null, \"Null value was provided for property \\\"a\\\"\")\r\n\t\trequire(s ne null, \"Null value was provided for property \\\"s\\\"\")\r\n\t\tnew B(\r\n\t\t\t__locator = None\r\n\t\t, _URI = java.util.UUID.randomUUID.toString\r\n\t\t, _ID = 0\r\n\t\t, _a = a\r\n\t\t, _aURI = a.URI\r\n\t\t, _aID = a.ID\r\n\t\t, _i = i\r\n\t\t, _s = s\r\n\t\t, _f = f)\r\n\t}\r\n\r\n\t\r\n\t\t\t\r\n\tprivate[myModule] def buildInternal(__locator: IServiceLocator\r\n\t\t, URI: String\r\n\t\t, ID: Int\r\n\t\t, a: namespace.myModule.A\r\n\t\t, aURI: String\r\n\t\t, aID: Int\r\n\t\t, i: Int\r\n\t\t, s: String\r\n\t\t, f: Float) = \r\n\t\tnew B(\r\n\t\t\t__locator = Some(__locator)\r\n\t\t, _URI = URI\r\n\t\t, _ID = ID\r\n\t\t, _a = a\r\n\t\t, _aURI = aURI\r\n\t\t, _aID = aID\r\n\t\t, _i = i\r\n\t\t, _s = s\r\n\t\t, _f = f)\r\n\r\n}\r\n","Scala/namespace.myModule.postgres.BRepository.scala":"package namespace.myModule.postgres\r\n\r\nimport hr.ngs.patterns._\r\n\r\n\r\n\r\n\r\nclass BRepository(\r\n\t  private val sessionFactory: org.pgscala.PGSessionFactory,\r\n\t  private val locator: IServiceLocator\r\n\t) extends namespace.myModule.IBRepository {\r\n\t\r\n\t\r\n\t\r\n\timport org.pgscala._\r\n\r\n\tval createFromResultSet = (rS: PGScalaResultSet) =>\r\n\t\tnamespace.myModule.postgres.BConverter.fromPGString(rS.one[String], locator)\r\n\r\n\tdef find(uris: Traversable[String]): IndexedSeq[namespace.myModule.B] = {\r\n\t\tval pks = if(uris eq null) Array.empty[String] else uris.filter(_ ne null).toArray\r\n\t\tif (pks.isEmpty) {\r\n\t\t\tIndexedSeq.empty\r\n\t\t}\r\n\t\telse {\r\n\t\t\tval formattedUris = postgres.Utils.buildSimpleUriList(pks)\r\n\t\t\tsessionFactory.using( _.arr(\"\"\"SELECT r\r\nFROM \"myModule\".\"B_entity\" r\r\nWHERE r.\"ID\" IN (%s)\"\"\".format(formattedUris)) (createFromResultSet)\r\n\t\t\t)\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate val typeConverter = namespace.myModule.postgres.BConverter\r\n\tprivate val rootTypeConverter = typeConverter.toPGString _\r\n\r\n\tdef persist(\r\n\t\t  insert: Traversable[namespace.myModule.B]\r\n\t\t, update: Traversable[(namespace.myModule.B, namespace.myModule.B)]\r\n\t\t, delete: Traversable[namespace.myModule.B]): IndexedSeq[String] = {\r\n\r\n\t\tsessionFactory.using{ dbSession =>\r\n\t\t\tval insertValues = insert.toArray\r\n\t\t\tval updateValues = update.toArray\r\n\t\t\tval deleteValues = delete.toArray\r\n\r\n\r\n\t\t\tif(insertValues.nonEmpty) {\r\n\t\t\t\tval ids = dbSession.getArr[Int](\"\"\"/*NO LOAD BALANCE*/SELECT nextval('\"myModule\".\"B_ID_seq\"'::regclass)::int FROM generate_series(1, @1);\"\"\", insertValues.size)\r\n\r\n\t\t\t\tinsertValues.zip(ids) foreach { case (item, id) => \r\n\t\t\t\t\titem.ID = id\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\tinsertValues foreach { item => item.URI = namespace.myModule.postgres.BConverter.buildURI(item.ID) }\r\n\t\t\tupdateValues foreach { case(_, item) => item.URI = namespace.myModule.postgres.BConverter.buildURI(item.ID) }\r\n\r\n\t\t\tval sqlCom = new StringBuilder(\"\"\"/*NO LOAD BALANCE*/SELECT \"myModule\".\"persist_B\"(\r\n\t\t\t\t\t%s::\"myModule\".\"B_entity\"[],\r\n\t\t\t\t\t%s::\"myModule\".\"B_entity\"[],\r\n\t\t\t\t\t%s::\"myModule\".\"B_entity\"[],\r\n\t\t\t\t\t%s::\"myModule\".\"B_entity\"[]\"\"\".format(\r\n\t\t\t\tpostgres.Utils.createArrayLiteral(insertValues, rootTypeConverter),\r\n\t\t\t\tpostgres.Utils.createArrayLiteral(updateValues map(_._1), rootTypeConverter),\r\n\t\t\t\tpostgres.Utils.createArrayLiteral(updateValues map(_._2), rootTypeConverter),\r\n\t\t\t\tpostgres.Utils.createArrayLiteral(deleteValues, rootTypeConverter)))\r\n\r\n\t\t\tsqlCom.append(\")\")\r\n\r\n\t\t\tdbSession.exec(sqlCom.toString)\r\n\r\n\r\n\t\t\tinsertValues.map(_.URI)\r\n\t\t} // using\r\n\t}\r\n\r\n}\r\n","Scala/namespace.myModule.IBRepository.scala":"package namespace.myModule\r\n\r\nimport hr.ngs.patterns._\r\n\r\n\r\n\r\ntrait IBRepository \textends IRepository[namespace.myModule.B]\twith IPersistableRepository[namespace.myModule.B] {\r\n\t\r\n}\r\n","Scala/namespace.myModule.postgres.snowBAConverter.scala":"package namespace.myModule.postgres\r\n\r\n\r\n\r\nimport org.pgscala.converters._\r\nimport org.pgscala.util._\r\nimport hr.ngs.patterns._\r\n\r\nobject snowBAConverter {\r\n\r\n\tprivate val logger = org.slf4j.LoggerFactory.getLogger(getClass)\r\n\r\n\tdef fromPGString(record: String, locator: IServiceLocator): namespace.myModule.snowBA = {\r\n\t\tval items = PGRecord.unpack(record)\r\n\t\tnamespace.myModule.snowBA(\r\n\t\t\tURI = items(URIPos)\r\n\t\t, ai = PGIntConverter.fromPGString(items(aiPos))\r\n\t\t, as = PGStringConverter.fromPGString(items(asPos))\r\n\t\t, af = PGFloatConverter.fromPGString(items(afPos))\r\n\t\t, i = PGIntConverter.fromPGString(items(iPos))\r\n\t\t, s = PGStringConverter.fromPGString(items(sPos))\r\n\t\t, f = PGFloatConverter.fromPGString(items(fPos))\r\n\t\t)\r\n\t}\r\n\r\n\tdef fromPGStringExtended(record: String, locator: IServiceLocator): namespace.myModule.snowBA = {\r\n\t\tval items = PGRecord.unpack(record)\r\n\t\tnamespace.myModule.snowBA(\r\n\t\t\tURI = items(URIPosExtended)\r\n\t\t, ai = PGIntConverter.fromPGString(items(aiPosExtended))\r\n\t\t, as = PGStringConverter.fromPGString(items(asPosExtended))\r\n\t\t, af = PGFloatConverter.fromPGString(items(afPosExtended))\r\n\t\t, i = PGIntConverter.fromPGString(items(iPosExtended))\r\n\t\t, s = PGStringConverter.fromPGString(items(sPosExtended))\r\n\t\t, f = PGFloatConverter.fromPGString(items(fPosExtended))\r\n\t\t)\r\n\t}\r\n\r\n\tdef toPGString(item: namespace.myModule.snowBA): String = {\r\n\t\tval items = new Array[String](columnCount) \r\n\t\titems(URIPos) = item.URI\r\n\t\titems(aiPos) = PGIntConverter.toPGString(item.ai)\r\n\t\titems(asPos) = PGStringConverter.toPGString(item.as)\r\n\t\titems(afPos) = PGFloatConverter.toPGString(item.af)\r\n\t\titems(iPos) = PGIntConverter.toPGString(item.i)\r\n\t\titems(sPos) = PGStringConverter.toPGString(item.s)\r\n\t\titems(fPos) = PGFloatConverter.toPGString(item.f)\r\n\t\tPGRecord.pack(items)\r\n\t}\r\n\r\n\tdef toPGStringExtended(item: namespace.myModule.snowBA): String = {\r\n\t\tval items = new Array[String](extendedColumnCount) \r\n\t\titems(URIPosExtended) = item.URI\r\n\t\titems(aiPosExtended) = PGIntConverter.toPGString(item.ai)\r\n\t\titems(asPosExtended) = PGStringConverter.toPGString(item.as)\r\n\t\titems(afPosExtended) = PGFloatConverter.toPGString(item.af)\r\n\t\titems(iPosExtended) = PGIntConverter.toPGString(item.i)\r\n\t\titems(sPosExtended) = PGStringConverter.toPGString(item.s)\r\n\t\titems(fPosExtended) = PGFloatConverter.toPGString(item.f)\r\n\t\tPGRecord.pack(items)\r\n\t}\r\n\r\n\tprivate var columnCount = -1\r\n\tprivate var extendedColumnCount = -1\r\n\r\n\tdef initializeProperties() {\r\n\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"snowBA_snowflake\").get(\"URI\") match {\r\n\t\t\tcase Some(index) => URIPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"URI\" in type myModule.snowBA_snowflake. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_snowBA_type-\").get(\"URI\") match {\r\n\t\t\tcase Some(index) => URIPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"URI\" in type myModule.snowBA. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tcolumnCount = postgresUtils.getColumnCount(\"myModule\", \"snowBA_snowflake\")\r\n\t\textendedColumnCount = postgresUtils.getColumnCount(\"myModule\", \"-ngs_snowBA_type-\")\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"snowBA_snowflake\").get(\"ai\") match {\r\n\t\t\tcase Some(index) => aiPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"ai\" in type myModule.snowBA_snowflake. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_snowBA_type-\").get(\"ai\") match {\r\n\t\t\tcase Some(index) => aiPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"ai\" in type myModule.snowBA. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"snowBA_snowflake\").get(\"as\") match {\r\n\t\t\tcase Some(index) => asPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"as\" in type myModule.snowBA_snowflake. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_snowBA_type-\").get(\"as\") match {\r\n\t\t\tcase Some(index) => asPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"as\" in type myModule.snowBA. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"snowBA_snowflake\").get(\"af\") match {\r\n\t\t\tcase Some(index) => afPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"af\" in type myModule.snowBA_snowflake. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_snowBA_type-\").get(\"af\") match {\r\n\t\t\tcase Some(index) => afPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"af\" in type myModule.snowBA. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"snowBA_snowflake\").get(\"i\") match {\r\n\t\t\tcase Some(index) => iPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"i\" in type myModule.snowBA_snowflake. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_snowBA_type-\").get(\"i\") match {\r\n\t\t\tcase Some(index) => iPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"i\" in type myModule.snowBA. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"snowBA_snowflake\").get(\"s\") match {\r\n\t\t\tcase Some(index) => sPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"s\" in type myModule.snowBA_snowflake. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_snowBA_type-\").get(\"s\") match {\r\n\t\t\tcase Some(index) => sPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"s\" in type myModule.snowBA. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"snowBA_snowflake\").get(\"f\") match {\r\n\t\t\tcase Some(index) => fPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"f\" in type myModule.snowBA_snowflake. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_snowBA_type-\").get(\"f\") match {\r\n\t\t\tcase Some(index) => fPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"f\" in type myModule.snowBA. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t}\r\n\r\n\t\r\n\tprivate var URIPos = -1 \r\n\tprivate var URIPosExtended = -1 \r\n\tprivate var aiPos = -1 \r\n\tprivate var aiPosExtended = -1 \r\n\tprivate var asPos = -1 \r\n\tprivate var asPosExtended = -1 \r\n\tprivate var afPos = -1 \r\n\tprivate var afPosExtended = -1 \r\n\tprivate var iPos = -1 \r\n\tprivate var iPosExtended = -1 \r\n\tprivate var sPos = -1 \r\n\tprivate var sPosExtended = -1 \r\n\tprivate var fPos = -1 \r\n\tprivate var fPosExtended = -1 \r\n}\r\n","Scala/namespace.myModule.snowBA.scala":"package namespace.myModule\r\n\r\nimport hr.ngs.patterns._\r\n\r\n\r\n\r\n\r\ncase class snowBA @com.fasterxml.jackson.annotation.JsonIgnore() (\r\n\t   URI: String,\r\n\t   ai: Int,\r\n\t   as: String,\r\n\t   af: Float,\r\n\t   i: Int,\r\n\t   s: String,\r\n\t   f: Float\r\n\t) extends IIdentifiable {\r\n\t\r\n\t\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonCreator private def this(\r\n\t\t@com.fasterxml.jackson.annotation.JacksonInject(\"__locator\") __locator: hr.ngs.patterns.IServiceLocator\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"URI\") URI: String\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"ai\") ai: Int\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"as\") as: String\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"af\") af: Float\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"i\") i: Int\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"s\") s: String\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"f\") f: Float\r\n\t) =\r\n\t  this(URI = URI, ai = ai, as = if (as == null) \"\" else as, af = af, i = i, s = if (s == null) \"\" else s, f = f)\r\n\r\n}\r\n\r\nobject snowBA{\r\n\r\n\t\r\n}\r\n","Scala/namespace.myModule.postgres.snowBARepository.scala":"package namespace.myModule.postgres\r\n\r\nimport hr.ngs.patterns._\r\n\r\n\r\n\r\n\r\nclass snowBARepository(\r\n\t  private val sessionFactory: org.pgscala.PGSessionFactory,\r\n\t  private val locator: IServiceLocator\r\n\t) extends namespace.myModule.IsnowBARepository {\r\n\t\r\n\t\r\n\t\r\n\timport org.pgscala._\r\n\r\n\tval createFromResultSet = (rS: PGScalaResultSet) =>\r\n\t\tnamespace.myModule.postgres.snowBAConverter.fromPGString(rS.one[String], locator)\r\n\r\n\tdef find(uris: Traversable[String]): IndexedSeq[namespace.myModule.snowBA] =\r\n\t\tif (uris == null || uris.isEmpty) {\r\n\t\t\tIndexedSeq.empty\r\n\t\t}\r\n\t\telse {\r\n\t\t\tsessionFactory.using( _.arr(\"\"\"\r\n\t\t\t\tSELECT s\r\n\t\t\t\tFROM \"myModule\".\"snowBA_snowflake\" s\r\n\t\t\t\tWHERE s.\"URI\" = ANY(@1);\r\n\"\"\", uris) (createFromResultSet)\r\n\t\t\t)\r\n\t\t}\r\n}\r\n","Scala/namespace.myModule.IsnowBARepository.scala":"package namespace.myModule\r\n\r\nimport hr.ngs.patterns._\r\n\r\n\r\n\r\ntrait IsnowBARepository \textends IRepository[namespace.myModule.snowBA] {\r\n\t\r\n}\r\n"}