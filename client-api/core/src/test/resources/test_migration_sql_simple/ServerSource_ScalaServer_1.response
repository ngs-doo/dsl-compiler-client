{"Scala/namespace.SystemConfiguration.scala":"package namespace\r\n\r\nimport hr.ngs.patterns._\r\n\r\nobject SystemConfiguration {\r\n\tdef initialize(container: IContainer) {\t\r\n\t\tpostgresUtils.loadIndexes(container[org.pgscala.PGSessionFactory])\r\n\t\tmyModule.postgres.initialize(container)\r\n\t}\r\n}","Scala/namespace.myModule.postgres.scala":"package namespace\r\npackage myModule\r\n\r\nimport hr.ngs.patterns._\r\n\r\npackage object postgres {\r\n\tdef initialize(container: IContainer) {\r\n\t\tval locator = container[IServiceLocator]\r\n\t\t\r\n\t\tnamespace.myModule.postgres.AConverter.initializeProperties \r\n\t\tcontainer.register[namespace.myModule.postgres.ARepository, namespace.myModule.IARepository]\r\n\t\tcontainer.register[namespace.myModule.postgres.ARepository, IRepository[namespace.myModule.A]]\r\n\t\tnamespace.myModule.postgres.BConverter.initializeProperties \r\n\t\tcontainer.register[namespace.myModule.postgres.BRepository, namespace.myModule.IBRepository]\r\n\t\tcontainer.register[namespace.myModule.postgres.BRepository, IRepository[namespace.myModule.B]]\r\n\t\tcontainer.register[namespace.myModule.postgres.ARepository, IPersistableRepository[namespace.myModule.A]]\r\n\t\tcontainer.register[namespace.myModule.postgres.BRepository, IPersistableRepository[namespace.myModule.B]]\r\n\t}\r\n}","Scala/namespace.myModule.postgres.AConverter.scala":"package namespace.myModule.postgres\r\n\r\n\r\n\r\nimport org.pgscala.converters._\r\nimport org.pgscala.util._\r\nimport hr.ngs.patterns._\r\n\r\nobject AConverter {\r\n\r\n\tprivate val logger = org.slf4j.LoggerFactory.getLogger(getClass)\r\n\r\n\tdef fromPGString(record: String, locator: IServiceLocator): namespace.myModule.A = {\r\n\t\tval items = PGRecord.unpack(record)\r\n\t\tnamespace.myModule.A.buildInternal(\r\n\t\t\t__locator = locator\r\n\t\t, URI = items(URIPos)\r\n\t\t, ID = PGIntConverter.fromPGString(items(IDPos))\r\n\t\t)\r\n\t}\r\n\r\n\tdef fromPGStringExtended(record: String, locator: IServiceLocator): namespace.myModule.A = {\r\n\t\tval items = PGRecord.unpack(record)\r\n\t\tnamespace.myModule.A.buildInternal(\r\n\t\t\t__locator = locator\r\n\t\t, URI = items(URIPosExtended)\r\n\t\t, ID = PGIntConverter.fromPGString(items(IDPosExtended))\r\n\t\t)\r\n\t}\r\n\r\n\tdef toPGString(item: namespace.myModule.A): String = {\r\n\t\tval items = new Array[String](columnCount) \r\n\t\titems(URIPos) = item.URI\r\n\t\titems(IDPos) = PGIntConverter.toPGString(item.ID)\r\n\t\tPGRecord.pack(items)\r\n\t}\r\n\r\n\tdef toPGStringExtended(item: namespace.myModule.A): String = {\r\n\t\tval items = new Array[String](extendedColumnCount) \r\n\t\titems(URIPosExtended) = item.URI\r\n\t\titems(IDPosExtended) = PGIntConverter.toPGString(item.ID)\r\n\t\tPGRecord.pack(items)\r\n\t}\r\n\r\n\tprivate var columnCount = -1\r\n\tprivate var extendedColumnCount = -1\r\n\r\n\tdef initializeProperties() {\r\n\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"A_entity\").get(\"URI\") match {\r\n\t\t\tcase Some(index) => URIPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"URI\" in type myModule.A_entity. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_A_type-\").get(\"URI\") match {\r\n\t\t\tcase Some(index) => URIPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"URI\" in type myModule.A. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tcolumnCount = postgresUtils.getColumnCount(\"myModule\", \"A_entity\")\r\n\t\textendedColumnCount = postgresUtils.getColumnCount(\"myModule\", \"-ngs_A_type-\")\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"A_entity\").get(\"ID\") match {\r\n\t\t\tcase Some(index) => IDPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"ID\" in type myModule.A_entity. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_A_type-\").get(\"ID\") match {\r\n\t\t\tcase Some(index) => IDPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"ID\" in type myModule.A. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t}\r\n\r\n\t\r\n\tprivate var URIPos = -1 \r\n\tprivate var URIPosExtended = -1 \r\n\tprivate var IDPos = -1 \r\n\tprivate var IDPosExtended = -1 \r\n\t\r\n\tdef buildURI(ID: Int) : String = {\r\n\t\tval _uriParts = new Array[String](1) \r\n\t\t_uriParts(0) = PGIntConverter.toPGString(ID)\r\n\t\tpostgres.Utils.buildURI(_uriParts)\r\n\t}\r\n}\r\n","Scala/namespace.myModule.A.scala":"package namespace.myModule\r\n\r\nimport hr.ngs.patterns._\r\n\r\n\r\n\r\n\r\nclass A @com.fasterxml.jackson.annotation.JsonIgnore  private(\r\n\t  private var _URI: String,\r\n\t  private var _ID: Int,\r\n\t  @transient private val __locator: Option[IServiceLocator]\r\n\t) extends Serializable with IIdentifiable {\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonProperty(\"URI\")\r\n\tdef URI = { \r\n\t\t_URI\r\n\t}\r\n\r\n\t\r\n\tprivate [namespace] def URI_= (value: String) { \r\n\t\t_URI = value\r\n\t\t\r\n\t}\r\n\r\n\t\r\n\toverride def hashCode = URI.hashCode\r\n\toverride def equals(o: Any) = o match {\r\n\t\tcase c: A => c.URI == URI\r\n\t\tcase _ => false\r\n\t}\r\n\r\n\toverride def toString = \"A(\"+ URI +\")\"\r\n\t\r\n\t\t\r\n\t def copy(): A = {\r\n\t\t\r\n\r\n\t\t\t\r\n\t\tnew A(_URI = this.URI, __locator = this.__locator, _ID = _ID)\r\n\t}\r\n\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonCreator private def this(\r\n\t\t@com.fasterxml.jackson.annotation.JacksonInject(\"__locator\") __locator: IServiceLocator\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"URI\") URI: String\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"ID\") ID: Int\r\n\t) =\r\n\t  this(__locator = Some(__locator), _URI = URI, _ID = ID)\r\n\r\n\t\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonProperty(\"ID\")\r\n\tdef ID = { \r\n\t\t_ID\r\n\t}\r\n\r\n\t\r\n\tprivate [namespace] def ID_= (value: Int) { \r\n\t\t_ID = value\r\n\t\t\r\n\t}\r\n\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonIgnore\r\n\tdef isNewAggregate() = __locator == None || _URI == null\r\n}\r\n\r\nobject A{\r\n\r\n\tdef apply(\r\n\t) = {\r\n\t\tnew A(\r\n\t\t\t__locator = None\r\n\t\t, _URI = java.util.UUID.randomUUID.toString\r\n\t\t, _ID = 0)\r\n\t}\r\n\r\n\t\r\n\t\t\t\r\n\tprivate[myModule] def buildInternal(__locator: IServiceLocator\r\n\t\t, URI: String\r\n\t\t, ID: Int) = \r\n\t\tnew A(\r\n\t\t\t__locator = Some(__locator)\r\n\t\t, _URI = URI\r\n\t\t, _ID = ID)\r\n\r\n}\r\n","Scala/namespace.myModule.postgres.ARepository.scala":"package namespace.myModule.postgres\r\n\r\nimport hr.ngs.patterns._\r\n\r\n\r\n\r\n\r\nclass ARepository(\r\n\t  private val sessionFactory: org.pgscala.PGSessionFactory,\r\n\t  private val locator: IServiceLocator\r\n\t) extends namespace.myModule.IARepository {\r\n\t\r\n\t\r\n\t\r\n\timport org.pgscala._\r\n\r\n\tval createFromResultSet = (rS: PGScalaResultSet) =>\r\n\t\tnamespace.myModule.postgres.AConverter.fromPGString(rS.one[String], locator)\r\n\r\n\tdef find(uris: Traversable[String]): IndexedSeq[namespace.myModule.A] = {\r\n\t\tval pks = if(uris eq null) Array.empty[String] else uris.filter(_ ne null).toArray\r\n\t\tif (pks.isEmpty) {\r\n\t\t\tIndexedSeq.empty\r\n\t\t}\r\n\t\telse {\r\n\t\t\tval formattedUris = postgres.Utils.buildSimpleUriList(pks)\r\n\t\t\tsessionFactory.using( _.arr(\"\"\"SELECT r\r\nFROM \"myModule\".\"A_entity\" r\r\nWHERE r.\"ID\" IN (%s)\"\"\".format(formattedUris)) (createFromResultSet)\r\n\t\t\t)\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate val typeConverter = namespace.myModule.postgres.AConverter\r\n\tprivate val rootTypeConverter = typeConverter.toPGString _\r\n\r\n\tdef persist(\r\n\t\t  insert: Traversable[namespace.myModule.A]\r\n\t\t, update: Traversable[(namespace.myModule.A, namespace.myModule.A)]\r\n\t\t, delete: Traversable[namespace.myModule.A]): IndexedSeq[String] = {\r\n\r\n\t\tsessionFactory.using{ dbSession =>\r\n\t\t\tval insertValues = insert.toArray\r\n\t\t\tval updateValues = update.toArray\r\n\t\t\tval deleteValues = delete.toArray\r\n\r\n\r\n\t\t\tif(insertValues.nonEmpty) {\r\n\t\t\t\tval ids = dbSession.getArr[Int](\"\"\"/*NO LOAD BALANCE*/SELECT nextval('\"myModule\".\"A_ID_seq\"'::regclass)::int FROM generate_series(1, @1);\"\"\", insertValues.size)\r\n\r\n\t\t\t\tinsertValues.zip(ids) foreach { case (item, id) => \r\n\t\t\t\t\titem.ID = id\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\tinsertValues foreach { item => item.URI = namespace.myModule.postgres.AConverter.buildURI(item.ID) }\r\n\t\t\tupdateValues foreach { case(_, item) => item.URI = namespace.myModule.postgres.AConverter.buildURI(item.ID) }\r\n\r\n\t\t\tval sqlCom = new StringBuilder(\"\"\"/*NO LOAD BALANCE*/SELECT \"myModule\".\"persist_A\"(\r\n\t\t\t\t\t%s::\"myModule\".\"A_entity\"[],\r\n\t\t\t\t\t%s::\"myModule\".\"A_entity\"[],\r\n\t\t\t\t\t%s::\"myModule\".\"A_entity\"[],\r\n\t\t\t\t\t%s::\"myModule\".\"A_entity\"[]\"\"\".format(\r\n\t\t\t\tpostgres.Utils.createArrayLiteral(insertValues, rootTypeConverter),\r\n\t\t\t\tpostgres.Utils.createArrayLiteral(updateValues map(_._1), rootTypeConverter),\r\n\t\t\t\tpostgres.Utils.createArrayLiteral(updateValues map(_._2), rootTypeConverter),\r\n\t\t\t\tpostgres.Utils.createArrayLiteral(deleteValues, rootTypeConverter)))\r\n\r\n\t\t\tsqlCom.append(\")\")\r\n\r\n\t\t\tdbSession.exec(sqlCom.toString)\r\n\r\n\r\n\t\t\tinsertValues.map(_.URI)\r\n\t\t} // using\r\n\t}\r\n\r\n}\r\n","Scala/namespace.myModule.IARepository.scala":"package namespace.myModule\r\n\r\nimport hr.ngs.patterns._\r\n\r\n\r\n\r\ntrait IARepository \textends IRepository[namespace.myModule.A]\twith IPersistableRepository[namespace.myModule.A] {\r\n\t\r\n}\r\n","Scala/namespace.myModule.postgres.BConverter.scala":"package namespace.myModule.postgres\r\n\r\n\r\n\r\nimport org.pgscala.converters._\r\nimport org.pgscala.util._\r\nimport hr.ngs.patterns._\r\n\r\nobject BConverter {\r\n\r\n\tprivate val logger = org.slf4j.LoggerFactory.getLogger(getClass)\r\n\r\n\tdef fromPGString(record: String, locator: IServiceLocator): namespace.myModule.B = {\r\n\t\tval items = PGRecord.unpack(record)\r\n\t\tnamespace.myModule.B.buildInternal(\r\n\t\t\t__locator = locator\r\n\t\t, URI = items(URIPos)\r\n\t\t, ID = PGIntConverter.fromPGString(items(IDPos))\r\n\t\t, a = null\r\n\t\t, aURI = items(aURIPos)\r\n\t\t, aID = PGIntConverter.fromPGString(items(aIDPos))\r\n\t\t)\r\n\t}\r\n\r\n\tdef fromPGStringExtended(record: String, locator: IServiceLocator): namespace.myModule.B = {\r\n\t\tval items = PGRecord.unpack(record)\r\n\t\tnamespace.myModule.B.buildInternal(\r\n\t\t\t__locator = locator\r\n\t\t, URI = items(URIPosExtended)\r\n\t\t, ID = PGIntConverter.fromPGString(items(IDPosExtended))\r\n\t\t, a = null\r\n\t\t, aURI = items(aURIPosExtended)\r\n\t\t, aID = PGIntConverter.fromPGString(items(aIDPosExtended))\r\n\t\t)\r\n\t}\r\n\r\n\tdef toPGString(item: namespace.myModule.B): String = {\r\n\t\tval items = new Array[String](columnCount) \r\n\t\titems(URIPos) = item.URI\r\n\t\titems(IDPos) = PGIntConverter.toPGString(item.ID)\r\n\t\titems(aURIPos) = item.aURI\r\n\t\titems(aIDPos) = PGIntConverter.toPGString(item.aID)\r\n\t\tPGRecord.pack(items)\r\n\t}\r\n\r\n\tdef toPGStringExtended(item: namespace.myModule.B): String = {\r\n\t\tval items = new Array[String](extendedColumnCount) \r\n\t\titems(URIPosExtended) = item.URI\r\n\t\titems(IDPosExtended) = PGIntConverter.toPGString(item.ID)\r\n\t\titems(aURIPosExtended) = item.aURI\r\n\t\titems(aIDPosExtended) = PGIntConverter.toPGString(item.aID)\r\n\t\tPGRecord.pack(items)\r\n\t}\r\n\r\n\tprivate var columnCount = -1\r\n\tprivate var extendedColumnCount = -1\r\n\r\n\tdef initializeProperties() {\r\n\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"B_entity\").get(\"URI\") match {\r\n\t\t\tcase Some(index) => URIPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"URI\" in type myModule.B_entity. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_B_type-\").get(\"URI\") match {\r\n\t\t\tcase Some(index) => URIPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"URI\" in type myModule.B. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tcolumnCount = postgresUtils.getColumnCount(\"myModule\", \"B_entity\")\r\n\t\textendedColumnCount = postgresUtils.getColumnCount(\"myModule\", \"-ngs_B_type-\")\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"B_entity\").get(\"ID\") match {\r\n\t\t\tcase Some(index) => IDPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"ID\" in type myModule.B_entity. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_B_type-\").get(\"ID\") match {\r\n\t\t\tcase Some(index) => IDPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"ID\" in type myModule.B. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"B_entity\").get(\"aURI\") match {\r\n\t\t\tcase Some(index) => aURIPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"aURI\" in type myModule.B_entity. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_B_type-\").get(\"aURI\") match {\r\n\t\t\tcase Some(index) => aURIPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"aURI\" in type myModule.B. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"B_entity\").get(\"aID\") match {\r\n\t\t\tcase Some(index) => aIDPos = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"aID\" in type myModule.B_entity. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t\tpostgresUtils.getIndexes(\"myModule\", \"-ngs_B_type-\").get(\"aID\") match {\r\n\t\t\tcase Some(index) => aIDPosExtended = index - 1\r\n\t\t\tcase None => logger.error(\"\"\"Couldn't find column \"aID\" in type myModule.B. Check if database is out of sync with code!\"\"\")\r\n\t\t}\t\t\r\n\t}\r\n\r\n\t\r\n\tprivate var URIPos = -1 \r\n\tprivate var URIPosExtended = -1 \r\n\tprivate var IDPos = -1 \r\n\tprivate var IDPosExtended = -1 \r\n\t\r\n\tdef buildURI(ID: Int) : String = {\r\n\t\tval _uriParts = new Array[String](1) \r\n\t\t_uriParts(0) = PGIntConverter.toPGString(ID)\r\n\t\tpostgres.Utils.buildURI(_uriParts)\r\n\t}\r\n\tprivate var aURIPos = -1 \r\n\tprivate var aURIPosExtended = -1 \r\n\tprivate var aIDPos = -1 \r\n\tprivate var aIDPosExtended = -1 \r\n}\r\n","Scala/namespace.myModule.B.scala":"package namespace.myModule\r\n\r\nimport hr.ngs.patterns._\r\n\r\n\r\n\r\n\r\nclass B @com.fasterxml.jackson.annotation.JsonIgnore  private(\r\n\t  private var _URI: String,\r\n\t  private var _ID: Int,\r\n\t  @transient private var _a: namespace.myModule.A,\r\n\t  private var _aURI: String,\r\n\t  private var _aID: Int,\r\n\t  @transient private val __locator: Option[IServiceLocator]\r\n\t) extends Serializable with IIdentifiable {\r\n\t\r\n\t\r\n\t\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonProperty(\"URI\")\r\n\tdef URI = { \r\n\t\t_URI\r\n\t}\r\n\r\n\t\r\n\tprivate [namespace] def URI_= (value: String) { \r\n\t\t_URI = value\r\n\t\t\r\n\t}\r\n\r\n\t\r\n\toverride def hashCode = URI.hashCode\r\n\toverride def equals(o: Any) = o match {\r\n\t\tcase c: B => c.URI == URI\r\n\t\tcase _ => false\r\n\t}\r\n\r\n\toverride def toString = \"B(\"+ URI +\")\"\r\n\t\r\n\t\t\r\n\t def copy(a: namespace.myModule.A = null): B = {\r\n\t\t\r\n\r\n\t\t\t\r\n\t\tnew B(_URI = this.URI, __locator = this.__locator, _ID = _ID, _a = if(a != null) a else _a, _aURI = if (a != null) a.URI else this._aURI, _aID = if(a != null) a.ID else this._aID)\r\n\t}\r\n\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonCreator private def this(\r\n\t\t@com.fasterxml.jackson.annotation.JacksonInject(\"__locator\") __locator: IServiceLocator\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"URI\") URI: String\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"ID\") ID: Int\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"aURI\") aURI: String\r\n\t, @com.fasterxml.jackson.annotation.JsonProperty(\"aID\") aID: Int\r\n\t) =\r\n\t  this(__locator = Some(__locator), _URI = URI, _ID = ID, _aURI = if (aURI == null) \"\" else aURI, _a = null, _aID = aID)\r\n\r\n\t\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonProperty(\"ID\")\r\n\tdef ID = { \r\n\t\t_ID\r\n\t}\r\n\r\n\t\r\n\tprivate [namespace] def ID_= (value: Int) { \r\n\t\t_ID = value\r\n\t\t\r\n\t}\r\n\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonIgnore\r\n\tdef isNewAggregate() = __locator == None || _URI == null\r\n\t\r\n\t\r\n\tdef a = { \r\n\tif(__locator.isDefined) {\r\n\t\t\tif (_a == null || _a.URI != aURI)\r\n\t\t\t\t_a = __locator.get[namespace.myModule.IARepository].find(aURI).orNull\r\n\t\t}\t\t\t\r\n\t\t_a\r\n\t}\r\n\r\n\t\r\n\tdef a_= (value: namespace.myModule.A) { \r\n\t\t_a = value\r\n\t\t\r\n\t\t_aURI = value.URI\r\n\t\t\r\n\t\tif(aID != value.ID)\r\n\t\t\taID = value.ID\r\n\t}\r\n\r\n\t\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonProperty(\"aURI\")\r\n\tdef aURI = {\r\n\t\t\r\n\t\t_aURI\r\n\t}\r\n\r\n\t\r\n\t\r\n\t@com.fasterxml.jackson.annotation.JsonProperty(\"aID\")\r\n\t def aID = { \r\n\t\t_aID\r\n\t}\r\n\r\n\t\r\n\tprivate [namespace] def aID_= (value: Int) { \r\n\t\t_aID = value\r\n\t\t\r\n\t}\r\n\r\n}\r\n\r\nobject B{\r\n\r\n\tdef apply(\r\n\t\ta: namespace.myModule.A\r\n\t) = {\r\n\t\trequire(a ne null, \"Null value was provided for property \\\"a\\\"\")\r\n\t\tnew B(\r\n\t\t\t__locator = None\r\n\t\t, _URI = java.util.UUID.randomUUID.toString\r\n\t\t, _ID = 0\r\n\t\t, _a = a\r\n\t\t, _aURI = a.URI\r\n\t\t, _aID = a.ID)\r\n\t}\r\n\r\n\t\r\n\t\t\t\r\n\tprivate[myModule] def buildInternal(__locator: IServiceLocator\r\n\t\t, URI: String\r\n\t\t, ID: Int\r\n\t\t, a: namespace.myModule.A\r\n\t\t, aURI: String\r\n\t\t, aID: Int) = \r\n\t\tnew B(\r\n\t\t\t__locator = Some(__locator)\r\n\t\t, _URI = URI\r\n\t\t, _ID = ID\r\n\t\t, _a = a\r\n\t\t, _aURI = aURI\r\n\t\t, _aID = aID)\r\n\r\n}\r\n","Scala/namespace.myModule.postgres.BRepository.scala":"package namespace.myModule.postgres\r\n\r\nimport hr.ngs.patterns._\r\n\r\n\r\n\r\n\r\nclass BRepository(\r\n\t  private val sessionFactory: org.pgscala.PGSessionFactory,\r\n\t  private val locator: IServiceLocator\r\n\t) extends namespace.myModule.IBRepository {\r\n\t\r\n\t\r\n\t\r\n\timport org.pgscala._\r\n\r\n\tval createFromResultSet = (rS: PGScalaResultSet) =>\r\n\t\tnamespace.myModule.postgres.BConverter.fromPGString(rS.one[String], locator)\r\n\r\n\tdef find(uris: Traversable[String]): IndexedSeq[namespace.myModule.B] = {\r\n\t\tval pks = if(uris eq null) Array.empty[String] else uris.filter(_ ne null).toArray\r\n\t\tif (pks.isEmpty) {\r\n\t\t\tIndexedSeq.empty\r\n\t\t}\r\n\t\telse {\r\n\t\t\tval formattedUris = postgres.Utils.buildSimpleUriList(pks)\r\n\t\t\tsessionFactory.using( _.arr(\"\"\"SELECT r\r\nFROM \"myModule\".\"B_entity\" r\r\nWHERE r.\"ID\" IN (%s)\"\"\".format(formattedUris)) (createFromResultSet)\r\n\t\t\t)\r\n\t\t}\r\n\t}\r\n\t\r\n\tprivate val typeConverter = namespace.myModule.postgres.BConverter\r\n\tprivate val rootTypeConverter = typeConverter.toPGString _\r\n\r\n\tdef persist(\r\n\t\t  insert: Traversable[namespace.myModule.B]\r\n\t\t, update: Traversable[(namespace.myModule.B, namespace.myModule.B)]\r\n\t\t, delete: Traversable[namespace.myModule.B]): IndexedSeq[String] = {\r\n\r\n\t\tsessionFactory.using{ dbSession =>\r\n\t\t\tval insertValues = insert.toArray\r\n\t\t\tval updateValues = update.toArray\r\n\t\t\tval deleteValues = delete.toArray\r\n\r\n\r\n\t\t\tif(insertValues.nonEmpty) {\r\n\t\t\t\tval ids = dbSession.getArr[Int](\"\"\"/*NO LOAD BALANCE*/SELECT nextval('\"myModule\".\"B_ID_seq\"'::regclass)::int FROM generate_series(1, @1);\"\"\", insertValues.size)\r\n\r\n\t\t\t\tinsertValues.zip(ids) foreach { case (item, id) => \r\n\t\t\t\t\titem.ID = id\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\tinsertValues foreach { item => item.URI = namespace.myModule.postgres.BConverter.buildURI(item.ID) }\r\n\t\t\tupdateValues foreach { case(_, item) => item.URI = namespace.myModule.postgres.BConverter.buildURI(item.ID) }\r\n\r\n\t\t\tval sqlCom = new StringBuilder(\"\"\"/*NO LOAD BALANCE*/SELECT \"myModule\".\"persist_B\"(\r\n\t\t\t\t\t%s::\"myModule\".\"B_entity\"[],\r\n\t\t\t\t\t%s::\"myModule\".\"B_entity\"[],\r\n\t\t\t\t\t%s::\"myModule\".\"B_entity\"[],\r\n\t\t\t\t\t%s::\"myModule\".\"B_entity\"[]\"\"\".format(\r\n\t\t\t\tpostgres.Utils.createArrayLiteral(insertValues, rootTypeConverter),\r\n\t\t\t\tpostgres.Utils.createArrayLiteral(updateValues map(_._1), rootTypeConverter),\r\n\t\t\t\tpostgres.Utils.createArrayLiteral(updateValues map(_._2), rootTypeConverter),\r\n\t\t\t\tpostgres.Utils.createArrayLiteral(deleteValues, rootTypeConverter)))\r\n\r\n\t\t\tsqlCom.append(\")\")\r\n\r\n\t\t\tdbSession.exec(sqlCom.toString)\r\n\r\n\r\n\t\t\tinsertValues.map(_.URI)\r\n\t\t} // using\r\n\t}\r\n\r\n}\r\n","Scala/namespace.myModule.IBRepository.scala":"package namespace.myModule\r\n\r\nimport hr.ngs.patterns._\r\n\r\n\r\n\r\ntrait IBRepository \textends IRepository[namespace.myModule.B]\twith IPersistableRepository[namespace.myModule.B] {\r\n\t\r\n}\r\n"}
